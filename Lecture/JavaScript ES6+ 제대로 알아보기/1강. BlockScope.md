#JavaScript #hoisting
# 1강. BlockScope

- `{ }`에 의해서 생기는 변수의 유효범위
	- `{ }`를 `function() { }`로 생각하면  편하다.
- `let`, `const`가 추가 되었다.
- `var`는 **블록 스코프**를 따르지 않는다. `let`, `const`만 **블록 스코프**를 따른다.

## Hoisting
- `var`
	- 변수명만 위로 끌어올리고, `undefined`를 할당한다.
- `let`, `const`
	- 변수명만 위로 끌어올린다. `undefined`를 할당하지 않아 `reference Error`가 발생한다.
	- 결국 호이스팅은 하는데, 값을 할당하지 않는 것이라 보면 된다.
- JavaScript에서 호이스팅 때문에 개발에서 골치아픈 일이 발생한다.
	- 코드 저 밑에서 변수, 함수를 선언해도 위에서 사용할 수 있기 때문에 예상치 못한 일이 발생한다.
- **TDZ**: **Temporal Dead Zone** (임시 사각지대)
	```js
	// TDZ 에제.
	if (true) {
		const a = 100;
		if (true) {
			console.log(a);	// reference Error가 발생한다.
			const a = 10;
		}
	}
	
	// var로 할 경우 정상동작한다.
	if (true) {
		var a = 100;
		if (true) {
			console.log(a);	// 100
			var a = 10;
		}
	}
	```
	- Ecmascirpt에세 정의한 개념은 아님. 다만 JavaScript 개발자는 이 명칭으로 사용한다. 명세를 지칭할 이름이 만들어지지 않음.

## this

```js
var temp = {
	a: 1,
	b: function() {
    const a = 100;
		this.a = 20;  // this -> obj를 가리킨다.
		{
      const a = 10; // block으로 둘러 쌓여 있어서 같은 이름의 변수 선언 가능.
      this.a = 30;	// this -> obj를 가리킨다.
		}
	}
};

console.log(temp.a);  // 1
temp.b();
console.log(temp.a);  // 30
```

- 함수 scope는 전역 변수, Block Scope는 바인딩을 하지 않는다. 즉, 밖에 있는 this를 그대로 사용한다.

## 모든 문 형태에 적용

- 블록 스코프 유효 범위를 말해준다.
- 대부분 아는 내용이라 적을만한 것은 없고 블록 스코프안에서만 유효범위가 동작한다는 것을 잊지 말자.
