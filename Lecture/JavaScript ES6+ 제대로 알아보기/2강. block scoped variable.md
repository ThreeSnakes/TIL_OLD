# 2강. block scoped variable

## let
- 다 아는 내용인데 한가지 var와 비교하는 부분은 기억해 두는 것이 좋을것 같다.

```js
var funcs = [];
for (var i = 0; i < 10; i ++) {
	funcs.push(function() {
		console.log(i)
	});
}
funcs.forEach(function(f) {
	f();
});
```

해당 코드의 목적은 0~9까지 출력을 하는 코드일꺼라 생각할 수 있다. 하지만 실제로 해당 코드를 돌려보면 10이 10번 출력된다. 왜 그럴까?

함수의 실행 컨텍스트는 함수가 실행될때 생성된다. 위 코드에서 함수가 실제로 실행될때 함수 내부에 없는 i 변수를 찾게 된다. 그런데 위 코드에서 i는 for 루프가 다 돌고 종료 조건인 10인 상태가 되버린다. 그래서 결국 0~9가 아닌 10이 10번 출력 되는 것이다.

그러면 이 문제를 어떻게 해결 할 수 있을까? 이전 let, const가 없는 es5 에서는 closure를 활용해서 문제를 풀어야 한다.

```js
var funcs = [];
for (var i = 0; i < 10; i ++) {
	funcs.push((function() {
		return function() {
			console.log(v);
		};
	})(i));
}
funcs.forEach(function(f) {
	f();
});

```

funcs 에 함수를 넣을때 즉시 실행 함수를 넘겨주고, 이 즉시 실행 함수 내부에서 클로저를 통해 변수를 넘겨 주는 것이다. 그러면 forEach문에서 함수가 실행될때 i를 찾을때는 클로저로 저장된 변수 i를 이용하기 때문에 0~9가 출력 되는 것이다.

하지만 이 경우 메모리에 많은 낭비가 생길수 있는데, closure는 지워주지 않는 이상 계속 남아있게 된다. 이 메모리를 지우는 것도 귀찮고, 지워줘야 하는 것이 문제이다.

Let을 이용하면 이런 문제가 발생하지 않는다.

```js
var funcs = [];
for (var i = 0; i < 10; i ++) {
	funcs.push(function() {
		console.log(i)
	});
}
funcs.forEach(function(f) {
	f();
});
```

이 경우에는 i값은 for문 블럭 스코프 안에 존재하기 때문에 함수가 실행될때 바로 변수 i를 찾게 되는것이다. ES6에서 부터는 굉장히 편하게 신경쓰지 않고 사용 할 수 있는 것이다.

## const

- 이미 알고 있는 내용..
- `constnat variable`의 약자이다.
- 선언할때 같이 할당을 해줘야 한다. 제힐당 안됨.


### Object.freeze와 deep copy

- const로 선언한 Object도 모두 상수로 만들고 싶을 경우 어떻게 해야 할까..?-
	- `Object.freeze()`함수를 이용하면 된다.
	```js
	const obj = { A: 1, B: 2 };
	Object.freeze(obj);
	```
	- 그런데 nested obj일 경우에는 위 방법으로는 안된다. `Object.freeze()` 함수는 deep 하게 적용되지 않는다.
	- nested obj를 상수화 시키고 싶다면, 내부 property를 순회하면서 `Object.freeze()`를 한다. 이런 방식을 `deepFreezing`이라 한다.

### 반복문 내부에서의 const

기본 for문 에서는 const를 쓰면 안되고, for-in, for-of 문에서는 const를 써도 된다.

## let, const  공통 사항

- block scope 안에서만 유효하다.
- var 와 let, const를 같이 쓰면 성능이 떨어진다.
- 초기화전 호출시 에러 발생
- TDZ
- var의 경우 전역변수로 선언하게 되면 이를 지울수 없다. 윈도우 객체로 선언하면 지울 수 있는데 전역객체는 삭제 할 수 없다. 하지만 let, const 는 다르게 동작한다.
