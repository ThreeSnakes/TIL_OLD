# chapter_11
## 의존적이거나 경직된 클래스가 되지 않게 하기

최근 몇년간의 개발자들의 경향을 보면 상속 보다는 합성을 사용하는 좋다고 말한다. 상속은 클래스들 간에 의존체(dependencies)가 존재하기 때문에 문제를 일으킬 여지가 있다. 이러한 의존체들 때문에 유지보수에 문제가 발생할 수 있는데, 이러한 문제점들로 인해서 어떤 개발자들은 상속을 전혀 사용하지 않거나 단일 계층 수준으로만 사용하는 개발자들도 존재한다고 한다. 그렇다면 합성에는 문제가 없을까? 또 그렇지도 않다. 합성은 묶임 문제가 발생한다. 응집체(aggregations)는 다른 객체에 포함된 객체이며(new 키워드로 생성된다), 결합체는(associations)는 매개변수 목록을 통해 다른 객체로 전달되는 객체이다. 응집체는 객체에 포함되어 있기 때문에 서로 밀접하게 연결되어 있다. 상속만이 클래스를 강하게 연관시키는게 아니라 응집체를 사용한 합성도 클래스들을 강하게 연관시킬수 있는 것이다. 다만 상속과 응집체를 사용한 클래스의 문제는 약간 다르다. 

상속의 경우 부모 클래스에서 발생한 문제가 자식 클래스까지 전파되는 문제가 발생한다.

응집체를 사용한 합성은 한 클래스안에 여러 클래스가 모두 포함된 클래스를 말하는데, 이런 클래스는 특별한 조립이 필요하지 않다. 이미 조립이 완성되서 나온 컴퓨터라 볼수 있다. ( 맥북을 생각해보면 되는데, 만약 맥북에서 특정 부품이 고장나면 해당 부품만 수리하는게 아니라 해당 제품을 다 고쳐야 한다. 그만큼 수리비가 많이 나온다. ) 하지만 한 클래스가 망가질 경우 전체 클래스가 망가지는 경우가 발생할 수 있다. 상속만큼 나쁜 문제가 발생할 수 있는 것이다.

결합체를 사용한 합성은 의존성이 있는 것들을 생성자의 매개 변수등으로 전달하는 형태의 합성을 말한다. ( 결합체는 조립형 PC라고 생각하면 된다. CPU가 망가지면 CPU만 고치거나 다른 것으로 변경해주면 된다. 고장나지 않은 물건을 궂이 교체할 필요가 없는 것이다.) 여기서 한 클래스가 망가지는 경우에는 망가진 클래스만 고쳐주면 된다. 

이러한 차이점은 왜 발생하는 것일까? 바로 **의존성**에 해답이 있다. 

상속의 경우 자식클래스는 부모클래스에 의존적이다. 자식 클래스는 부모 클래스가 존재하지 않으면 생성할 수 없다. 그만큼 강하게 의존적이라는 것이다. 응집체를 사용한 합성을 보자. 응집체를 사용한 합성의 경우 class 내부에서 new 연산자를 통해서 개별 클래스를 합성하는 형태이다. 위에서 이야기 했다시피 응집체를 이용한 합성은 이미 완성된 제품(Class)이다. 이미 만들때 부터 강하게 서로 의존적인 클래스가 되는 것이다. 반면에 결합체를 사용한 합성은 개별로 만들어진 부품을 하나의 더 큰 개념의 클래스로 합치는 형태이다 보니 상속이나 응집체를 이용한 합성보다 덜 의존적이게 된다는 것이다. ( 완전히 자유롭다는 뜻은 아니다. 그만큼 덜 의존적이라는 것이다. ) 

그러면 상속 보다는 응집체를 이용한 합성이 좋고, 응집체를 이용한 합성보다는 결합체를 이용한 합성이 좋다는 것을 알았다. 상속에서 응집체를 이용한 합성을 이용할때는 상속을 안쓰고 합성을 하는 방향으로 코드를 작성하면 된다. 그러면 결합체를 이용한 합성을 이용하려면 어떻게 해야 할까? 

결합체를 이용한 합성을 만들때 사용하는 것이 **의존성 주입**이다.

### 의존성 주입(Dependency Injection)

의존성 주입은 쉽게 생각하면 어떠한 Class가 사용할 물건(Class가 될수도 있고, Service가 될 수도 있다.)을 물건 스스로가 결정하는게 아니라, 물건에게 이걸 사용해라 라고 말해주는 것이다. 즉, Class는 사용하는 물건이 어떻게 생성되야 하는지, 어떻게 구성되어 있는지 알 필요가 없다. 그냥 어떻게 사용만 하면 되는것인지 알면 되는 것이다. 물건을 어떻게 사용하는지(인터페이스)만 알고 있으면 되고, 객체를 어떻게 생성하는지에 대해서는 자유로워 지는 것이다. 즉 생성과 사용을 분리하는 것이라 보면 된다.

그렇다면 의존성을 주입할 수 있는 방법에는 어떤것이 있을까.?

1. 생성자를 이용해 전달한다.
	- 인스턴스를 생성할때 생성자에 내부에 사용할 객체의 인스턴스를 넘겨주는 형태이다.
2. setter()를 통해 전달한다.
	- 인스턴스가 생성된 이후 setter 메소드를 통해서 인스턴스를 넘겨주어 주입하는 형태이다.

다만 setter()를 통한 주입은 되도록 하지 말자. 물론 코드를 작성하다 보면 어쩔수 없는 경우는 있겠지만 되도록이면 생성자를 이용한 DI를 이용해야 한다.
추가로 spring에서는 필드 주입이라는 형태가 있는것으로 보인다. 다만 스프링 한정으로 보여 이는 별도로 정리하지는 않겠다. 

### 의존성 주입의 다양한 이점

의존성 주입을 통해서 결합도를 낮출수 있는 것은 위에서 설명해서 알고 있다. 그러면 다른 이점은 무엇이 있을까? 조금더 검색을 해보니 다음과 같은 이점이 있다고 한다.

1. 재사용성을 높여준다.
2. 테스트에 용의해진다.
3. 코드가 단순해진다.

### 정리

코드를 작성하면 어떻게 의존성을 줄일 수 있는지에 대해서 고민 해봐야 한다. 상속이 좋다, 나쁘다를 생각하기 보다는 어떻게 더 좋은 코드를 작성할 수 있는지에 대해서 고민을 해보자. 또한 의존성이라는 개념에 대해서 잊지 말아야 한다. 