# chapter_10
## 디자인 패턴

디자인 패턴은 재사용 가능한 소프트웨어 개발 개념에 아주 적합하다. 객체지향 개발은 모두 재사용에 관한 것이므로 패턴과 객체지향 개념은 함께 진보하였다.

GoF라 불리우는 4인조(에릭 감마, 리차드 헬름, 랄프 존슨, 존 블리시데스)가 집필한 `Design Patterns:Elements of Reusable Object-Oriented Software`를 통해서 널리 알려졌다.

### MVC 패턴

`MVC`란 `Model`, `View`, `Controller`의 약어로서 **Model은 애플리케이션 객체**, **view는 화면 표현**, **Controller는 사용자 인터페이스가 사용자 입력에 반응하는 방식**을 정의한다.

과거에는 이 MVC가 단일 엔티티에 작성되어 있는 형태로 개발되어 왔다. (현재 사내 regacy 프로젝트가 이런 구조로 되어 있어서 항상 문제라 생각한다.) 이런 방식의 경우 결합도가 너무 높아서 어느 한부분을 수정하면 다른 부분에도 영향을 끼치며, 어디까지 영향을 끼치는지 전부 확인해야 한다. 하지만 MVC 패러다임에서는 이 세 가지 컴포넌트에 개별적이며 구별되는 인터페이스로 구성된다. 따라서 어느 한 부분만 변경하려 한다면 수정이 필요한곳 한 군데만 수정하면 된다. 

MVC는 기본적인 프로그래밍 문제와 관련된 특정 컴포넌트 간의 인터페이스(사용자 인터페이스 생성, 비지니스 로직 및 그뒤에 있는 데이터에 대한 연결)를 명시적으로 정의한다. MVC 개념을 다르고 사용자 인터페이스, 비지니스 로직 및 데이터를 분리하면 시스템은 결합도는 낮아지고 응집도는 높아진다. 

MVC 개념은 모든 디자인 패턴의 시작이라 볼 수 있다.

### 디자인 패턴의 종류

디자인 패턴은 크게 생성 패턴, 구조 패턴, 행위 패턴 이 3가지 범주로 구분할 수 있다. 

#### 생성 패턴(creation patterns)

객체를 인스터스화 하지 않은 채로 객체를 만든다. 이를 통해 특정 사례에 대해 어떤 객체를 생성해야 할지 결정할 때 프로그램의 유연성이 높아 진다. 이는 객체의 생성과 참조 과정을 추상화하여 객체가 생성되거나 변경되어도 구조에 영향을 받지 않도록 하는 것이다.

책에는 패턴명만 나와 있었고, 상세 설명은 [rollercoaster25님의 블로그](https://rollercoaster25.tistory.com/76)를 참조 하였다.

- 추상 팩토리(Abstract factory)
	- 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관/의존하는 객체들의 그룹으로 생성하는 방식이다.
- 빌더(Builder)
	- 작게 분리된 인스턴스를 건축하듯이 조합하여 객체를 생성하는 패턴이다.
- 팩토리 메서드(Factory method)
	- 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴이다.
- 프로토타입(Prototype)
	- 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴이다.
- 싱글톤(singleton)
	- 생성된 객체의 참조는 어디서나 가능하지만 여러 프로세스가 동시에 참조는 불가능하도록 한 패턴, 유일한 인스턴스임을 보장하여 불필요한 메모리 낭비를 막는데 사용한다.

#### 구조 패턴(structural patterns)

구조패턴은 객체 그룹에서 더 큰 구조를 만드는데 사용한다. 

책에는 패턴명만 나와 있었고, 상세 설명은 [rollercoaster25님의 블로그](https://rollercoaster25.tistory.com/76)를 참조 하였다.

- 어댑터(Adapter)
	- 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴
- 브릿지(Bridge)
	- 구현부에서 추상층을 분리하여 서로가 독립적으로 확장할 수 있도록 구성한 패턴 (기능과 구현을 두개의 별도 클래스로 구현한 것)
- 컴포지션(Composite)
	- 여러 객체를 가진 복합 객체와 단일 객체를 구분이 다루고자 할때 사용하는 패턴이다. 일종의 트리구조라 생각하면 된다.
- 데코레이터(Decorator)
	- 객체 간의 결합을 통해서 능동적으로 기능을 확장할 수 있는 패턴이다. 임의의 객체에 부가적인 기능을 추가하기 위해서 다른 객체를 덧붙이는 방식이다.
- 파사드(Facade)
	- 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브클래스의 기능들을 던 간편하게 사용할 수 있게 하는 패턴이다.
- 플라이웨이트(Flyweight)
	- 인스턴스가 필요할 때마다 매번 생성하지 않고, 가능한 한 공유해서 메모리 절약을 할때 사용하는 패턴이다.
- 프록시(Proxy)
	- 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴이다.

#### 행위 패턴(Behavioral patterns)

책에는 패턴명만 나와 있었고, 상세 설명은 [rollercoaster25님의 블로그](https://rollercoaster25.tistory.com/76)를 참조 하였다.

- 책임 연쇄(Chain of responsibility)
	- 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체가 처리하는 형태의 패턴
- 커맨드(Command, '명령') 패턴
	- 요청을 객체의 형태로 캡슐화해서 재이용하거나 취소할 수 있도록 필요한 정보를 저장하거나 로그에 남기는 패턴
- 인터프리터(interpreter, '해설자') 패턴
	- 언어에 문법 표현을 정의하는 패턴, SQL/통신 프로토콜 개발에 사용된다.
- 이터레이터(iterator, '반복자') 패턴
	- 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패텅
- 미디에이터(mediator, '중재자') 패턴
	- 객체들간의 복잡한 상호작용을 캡슐화 하여 객체로 정의하는 패턴, 객체 사이의 의존성을 줄여 겹합도를 감소시킨다.
- 메멘토(memento, '기념비') 패턴
	- 특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴.
- 옵저버(Observer, '관찰자') 패턴
	- 한 객체의 상태가 변화하면 다른 객체들에게 변화된 상태를 전달하는 패턴.
- 스테이트(State, '상태') 패턴
	- 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴.
- 스트레테지(Strategy, '전략') 패턴
	- 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴.
- 템프릿 메서드(Template method) 패턴
	- 유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에 정의하는 패턴.
- 비지터(Visitor, '방문자') 패턴
	- 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴.

### 안티 패턴

디자인 패턴은 좋은 경험으로 부터 얻어진 결과라면, 안티 패턴은 나쁜 경험으로부터 얻어진 패턴이다. 안티 패턴은 피해야할 패턴이라 볼 수 있다.

- 싱글톤(Singleton)
- 서비스 로케이터(Service locator)
- 매직 스트링/매직 넘버(Magic strings/Magic numbers)
- 인터페이스 부풀리기(Interface bloat)
- 예외에 기반한 코딩(Coding by exception)
- 오류 숨기기/오류 삼키기(Error hiding/swallowing)