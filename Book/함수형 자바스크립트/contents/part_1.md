# 함수형 자바스크립트

## 날짜: 2019.12.18 ~

## Part_1. 함수형으로 사고하기

### 목차

1. [함수형 길들이기](#함수형-길들이기)

#### 함수형 길들이기

- 자바스크립트는 언어 내부에 상태를 적절히 관리할 장치가 마땅치않다. ( 자바스크립트 동적 언어이다 보니 상태가 계속 변경 될수 잇음을 말하는것이가? )
- **함수형 프로그래밍(FP: Functional Programming)**은 애플리케이션을 작성할 때 확장성, 모듈화, 재사용성, 테스트 용이성 등 많은 도움을 줄 수 있다.
- FP는 프레임워크나 도구가 아니다. 지금까지 객체지향으로 개발해왔던 사고와 근본적으로 다르며 FP를 사용하기 위해서는 사고를 전환해야 한다.
- FP의 진정한 목적은 어떤 결과를 만드는 함수를 적용하는 그런 단순한 차원이 아니다. 진짜 목표는 **애플리케이션의 부수효과(side effect)를 방지하고 상태 변이(mutation of state)를 감소하기 위해 데이터의 제어 흐름과 연산을 추상(abstract) 하는 것이다.**
- 함수형 프로그램을 이해하려면, 다음 기본 개념을 이해해야 한다
  - **선언적 프로그래밍**
    - FP는 큰 틀에서 선언전 프로그래밍 패러다임에 속한다
    - 명령형 프로그램은 어떤 겨로가를 내기 위해 시스템의 상태를 변경하는 구문을 위에서 아래로 죽 늘어놓은 순차열에 불과하다. 이와 달리 선언적 프로그래밍은 서술부와 평가부를 분리하여, 제어흐름이나 상태 변화를 특정하지 않고도 프로그램 로직이 무었인지를 **표현식**으로 나타낸다
    - FP를 하기 위한 첫번째 작업은 명령형으로 작성된 코드를 함수로 추상화 하는 것이다
    - FP는 **무상태성**과 **불변성**은 지향한다
    - FP는 부수효과와 상태 변이를 일으키지 않는 **순수함수**를 써야 한다.
  - **순수 함수**
    - 기본적으로 FP는 순수함수로 구성된 불변 프로그램을 구축을 전재로 한다. 그럼 순수 함수는 무었일까?
      - 주어진 입력에만 의존할 뿐, 평가 도중 또는 호출 간 변경될 수 있는 숨겨진 값이나 외부 상태와 무관하게 동작 하는 함수
      - 전역 객체나 레퍼런스로 전달된 매개변수를 수정하는 등 함수 스코프 밖에서 어떠한 변경도 일으키지 않는 함수
      - 예시 코드

        ``` js
        // 아래 함수는 함수 밖에 있는 외부 스코프의 변수를 읽고 수정한다.
        // 이 함수는 부수효과를 동반하기 때문에 순수함수가 아니다.
        var counter = 0
        function increment() {
          return ++counter;
        }

        // 아래 함수는 호출 될때마다 값이 달라진다.
        // 이는 순수함수가 아니다
        function getDate() {
          return new Date();
        }

        // 억지로 만들어낸 예제이다. 말이 안되긴 한다;;
        // 아래는 매개변수로 들어온 값을 변경해버린다. 이것도 순수함수가 아니다.
        function add(x, y) {
          x += y
          return x;
        }
        ```

    - FP는 모든 상태 변이를 근절을 주장하는 것아니다. 상태 변이를 줄이고 관리할 수 있는 프레임워크를 제공하여 순수/불순 함수를 구분하자는 것이다
    - **함수가 일관된 반환값을 보장하도록 해서 전체 함수 결과를 예측 가능한 방향으로 유도하는 것이 목표이다**
  - **참조 투명성**
    - 어떤 함수가 동일한 입력을 받았을 때 동일한 결과를 내면 이를 **참조 투명한 함수**라 한다.
    - 참조 투명함 함수 사용시 이점
      - 테스트가 쉬워진다
      - 전체 로직을 파악하는 것도 쉬원진다.
      - 리팩토링/치환등의 작업을 쉽게 할 수 있다.
    - 참조 투명한 함수를 작성할 때는 객체를 변이 하지 않는 것이 중요하다.
  - **불변성**
    - 불변 데이터는 한번 생성된 후 바뀌지 않는다. 하지만 array나 Object 등의 객체는 불변이 아니어서 함수 인수로 전달해도 원래 내용이 변경되어 부수효과가 발생할 수 있다.
- 결국 **FP**는 **외부에서 관찰 가능한 부수효과가 제거된 불변 프로그램을 작성하기 위해 순수함수를 선언적으로 평하하는 것을 말한다.**
- 함수를 순수 연산의 관점에서 데이터를 절대 변경하지 않는 고정된 작업 단위로 바라본다면 버그는 줄어들게 되있다
- FP로 개발을 하면 무엇이 좋아질까? 일반적으로 FP로 개발을 하게 된다면 다음처럼 작업을 하게 될 것이다.
  - **간단한 함수로 작업을 분해한다.**
    - 함수를 작게 분해할 경우 작업 단위는 바로 함수 자신이 된다.
    - FP에서 모듈화는 단일성의 원리와 밀접한 관려이 있다. 함수는 저마다 한 가지 목표만 바라봐야 한다는 것이다
    - 이런 작은 함수 여러개를 실행해서 하나의 큰 작업을 진행하는 것이다. 이때 **합성** 기법 개념이 나온다.
      - 설명

      ``` text
      두 함수 f, g가 있을때 이 두개를 함성하면 수학적으로 다음과 같아진다. 'f 합성 g' 라고 있는다.
      f * g = f(g(x))
      ```

      - 예시

      ``` js
      // 위에 함성을 함수로 구현한 것이 합성 함수이다.
      var run = function(f, g) {
        return function(x) {
          return f(g(x));
        };
      };

      const multiplier = (x) => {
        return x * x;
      };

      const plus1 = (x) => {
        return x + 1;
      }

      // run에 함수 2개를 넣으면 함수가 리턴된다. 이 함수를 실행시켜야 합성 되는 것이다.
      const test = run(multiplier, plus1);
      // 위 코드는 결국 multiplier(plus1(x))가 된다.
      console.log(test(10));  // 121
      ```

      - 위 코드의 run처럼 다른 함수를 인수로 받는 함수를 **고계함수**라 한다.
      - lodash에도 위 run과 같은 동작을 하는 코드가 있다. 바로 _.flow, _.flowRight라는 코드인데 나중에 살펴보자.
  - **흐름 체인으로 데이터를 처리한다.**
  - **리액티브 패러다이믕ㄹ 실현하여 이벤트 중심 코드의 복잡성을 줄인다.**
