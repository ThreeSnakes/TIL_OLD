# 값 객체

## 값 객체란?
- 프로그래밍 언어에는 `원시 데이터 타입`(`int`, `char`, `string`...)이 존재하는데, 이 값만을 이용해 시스템을 개발할 수 있다. 때로는 `시스템 특유의 값`을 정의해야 할 때가 있는데, 이러한 `시스템 특유의 값`을 표현하기 위해 정의하는 객체를 `값 객체`라고 한다.
- `값 객체`는 `객체`이기도 하고 동시에 `값`이기도 하다. 따라서 이를 `값 객체`라고 부른다. `도메인 주도 설계`에서 말하는 값 객체는 이렇듯 `시스템 특유의 값`을 나타내는 객체를 말한다.


## 값의 성질과 값 객체 구현
값 객체를 이해하기 위해서는 일단 값의 성질을 이해해야한다. 대표적으로 다음 세가지를 꼽을수 있다.
1. **변하지 않는다. (불변성)**
2. **주고받을 수 있다.**
3. **등가성을 비교할 수 있다.**

### 불변성
값은 변하지 않는다. 변수에 값을 수정하는 것은 값을 대입하는것이다. 값 자체는 변경되지 않는다.
```js
let a = 10; // a는 10이라는 값을 가지고 있게 된다.
a = 20; // a에 20이라는 값이 대입되었다. 수정 되는 것은 변수의 내용이지 값(10) 자체가 변경되는 것은 아니다.
```
값은 변하지 않아야한다. 값이 변한다면 이는 개발자에게 많은 혼란을 야기할 수 있다. 그렇기 때문에 `값 객체에서는 값을 수정하는 메서드를 제공해서는 안된다.`


### 교환 가능하다
값을 불변하다. 하지만 불변 값으로만 코드를 완성하는 것은 어렵기 때문에 값을 수정할 필요는 있다. 여기서 수정이란 값 자체를 바꾸는게 아니라 대입을 하라는 것이다. `즉 값 객체는 바뀌는게 아니라, 다른 값 객체로 대입되는 것이다.`
```js
const amount = Cash(10);
amount = Cash(100);
// amount에 있는 값은 10에서 100으로 변경 되었다.
// 하지만 Cash(10)으로 값 자체는 변경되지 않는다, 새로운 Cash(100)으로 변경되는 것이다.
```
값 객체는 값과 마찬가지로 대입문을 통해 교환의 형식으로 변경되어야 한다.

### 등가성 비교
값은 아래와 같이 비교할 수 있다. (숫자는 숫자, 문자는 문자... 다만 JavaScript는..?)
```js
console.log(1 === 1) // True
console.log(1 === 1000) // False
console.log('a' === 'a') // True
console.log('a' === 'c') // False
```
하지만 객체를 이용해서 비교한다고 생각한다면 다음처럼 두가지 방법을 이용해 비교할 수 있을것이다.
```js
// method를 이용해서 비교하는 경우
const amount1 = Cash(10);
const amount2 = Cash(100);
console.log(amount1.equals(amount2)); // equals라는 method가 있다고 가정하자.

// property를 꺼내서 비교하는 경우
console.log(amount1.value === amount2.value)
```
그런데 Property를 이용해서 비교하는 방법은 이상하게 생각해야 한다. 값 객체도 결국 값이다. 값의 값을 꺼내는 것은 부자연스럽다. 값 객체는 시스템 고유의 값이고 결국 값이기 때문에 직접 값끼리 비교하는 방식이 자연스럽다. `자연스러운 코드를 사용하려면 값 객체를 비교하는 메서드를 제공하는게 좋은 방법이다.` 

한데 단순히 값을 비교하는 코드를 자연스럽게 만든다는 목적으로 메서드를 작성하면 쓸데없이 코드만 늘어나거나 찜찜하다고 생각할 수 있다. 하지만 이는 값 객체에 property가 추가 될때 이 장점을 알 수 있게 된다. 만약 위 코드에서 통화(Currency)가 추가되고, 같은 통화일 경우에만 비교가 가능하다고 해보자. 
```js
const amount1 = Cash(10, 'KRW');
const amount2 = Cash(100, 'USD');

// method를 비교하는 경우
console.log(amount1.equals(amount2))

// property를 꺼내서 비교하는 경우
console.log(amount1.currency === amount2.currency && amount1.value === amount2.value)
```
위 코드처럼 코드가 길어지며, 이렇게 코드를 비교하는 모든 코드에 새롭게 추가된 비교조건을 수정해야 한다. 하지만 method를 이용하는 경우 method에 조건만 달아주면 된다. 기존 equals를 쓰는 경우에는 수정할 필요가 없는 것이다.

이렇게 비교뿐만 아니라, 값의 속성을 다루는 처리 역시 값 객체에서 제공하게 하면 수정할 곳을 줄일 수 있다. 

## 값 객체가 되기 위한 기준
모든 값을 각 객체로 만들면 좋겠지만, 현실을 그렇지 못하다. 어디까지를 값 객체로 만들것인지를 잘 고민해야 한다. 모든 값을 각 객체로 만들 필요가 없다면 궂이 만들필요가 없다. 개발자에 판단에 따라서 이를 잘 선택해야 한다.

저자는 `규칙이 존재하는 값인가?`, `낱개로 다루어야 하는가?` 이 2개로 값 객체를 정의한다고 한다.

## 행동이 정의된 값 객체
값 객체에서 중요점 중 하나는 독자적인 행위를 정의할 수 있다는 것이다. 값 객체는 값이기도 하지만 객체이기도 하다, 그렇기 때문에 해당 컨테이너가 행할 수 있는 Method를 가질 수 있는 것이다.
```js
const amount1 = Cash(10, 'KRW');
const amount2 = Cash(100, 'KRW');

const amount3 = Cash.add(amount3) // = new Cash(110, 'KRW')과 같다.
```
이 Method를 톨해서 객체가 어떤일을 할 수 있는지도 알수 있는데, 반대로 정의되지 않은 값이라면 할 수 없다는 것도 알 수 있다.

## 값 객체를 도입했을 대의 장점
값 객체를 만든다는 것은 Class의 수가 늘어난다는 것과 동일하다. 기존에는 원시 타입 값을 '잘 활용하는' 방법으로 개발해왔기 때문에 많은 수의 클래스를 정의하는 것을 껄끄러워하는 개발자도 많다. 값 객체를 도입하려면 여기에 따르는 심리적 장애물을 넘어야 한다. 이러한 심리적 장애물을 넘도록 해주기 위해서 장점을 소개한다.
1. 표현력이 증가한다.
2. 무결성이 유지된다.
3. 잘못된 대입을 방지한다.
4. 로직이 코드 이곳저곳에 흝어지는 것을 방지한다.

### 표현력의 증가
여러가지 키로 조합된 일련번호가 있다고 생각해보자. 이를 단순히 원시 타입으로 표현하면 단순히 아래처럼 표시될수 있을 것이다.
``` js
const clientActiveId = '000-KR-123' // 타입 + 국가코드 + ClietnID
```
하지만 이를 값 객체로 표현할 경우 표현력은 증가 될수 있다. 
```js
class ClientActiveId {
	private type;
	private countryCode;
	private clientId;
	
	constructor(type, countryCode, clientId) {
		this.type = type;
		this.countryCode = countryCode;
		this.clientId = clientId
	}
	
	toValue() {
		return `${this.type}-${this.country}-${this.clientId}`;
	}
}
```
값 객체는 자기 정의를 통해서 자신이 무엇인지에 대한 정보를 제공하는 자기 문서화를 돕는다.

### 무결성의 유지
시스템에는 각 값이 준수해야 할 규칙이 존재한다. 값 객체는 이러한 규칙을 한곳에서 관리할 수 있도록 해주며, 무결성을 유지할 수 있도록 해준다.

예를 들면 위 예제에서 type은 3자리 숫자만 받아야 한다고 생각해보자. 원시값으로 표현하는 경우 type이라는 값이 3자리 숫자인지 매번 체크를 해줘야 하지만, 값 객체를 사용하는 경우 다음처럼 관리 할 수 있다.

``` js
class Type {
	private _value;	

	consturctor(type) {
		if (type < 100 || type > 999) throw new Error('invalid type');
		this._value = type;
	}
	
	get value {
		return this._value;
	}

```
이렇게 만든다면 애초에 잘못된 값이 들어오는 경우를 방지할 수 있게 해준다. 또한 해당 값을 사용할때마다 체크하는 코드를 넣을 필요도 없다. 값 객체 Class에서 이를 체크하기 때문데 이러한 조건을 한곳에서 관리 할 수 있게 된다.

### 잘못된 대입 방지하기
대입문을 잘못 사용하는 경우를 방지 할 수 있다. 만약 위 예제에서 type, countryCode가 둘다 string이라고 생각해보자. 이럴 경우 type, countryCode를 바꿔서 대입해도 문제는 발생하지 않고 프로그램은 정상 동작한다.
```js
const clientActiveId = new ClientActiveId('000', 'KR', 123) // 정상적인 경우
const clientActiveId = new ClientActiveId('KR', '000', 123) // 순서가 바뀌어도 문제없다. 하지만 실제로 이렇게 구동하면 버그가 발생한다.
```
한데 값 객체를 사용하면 이런 문제를 방지 할 수 있다. Type, CountryCode 라는 타입을 설정해서 이를 넣는다면 순서를 다르게 넣더라도 타입이 다르기 때문에 컴파일 단계에서부터 에러를 알 수 가 있다. (물론 자바스크립트에서는 안되곘지만 타입스크립트는 이를 잡아준다.)

### 로직을 한곳에 모아두기
이 항목은 위에서도 언급을 하였는데, DRY 원칙에 의해서도 코드 중복을 방지하는 것은 매우 중요하다. 중복된 코드가 많아지면 코드를 수정하는 난이도가 상승하게 된다. 하지만 값 객체를 사용하면 이를 해결할 수 있다. 로직을 값 객체 한곳에 모아둘수 있기 때문이다. 이는 다시 말하면 규칙이 변경되거나 잘못되었때 수정할 곳은 값 객체에서 규칙을 정해둔곳 한곳만 수정하면 된다는 것이다.

## 정리
- `값 객체`는 `시스템 고유의 값`을 만드는 것이다.
- 도메인에는 다양한 규칙이 있는데, 값 객체를 정의함으로서 이러한 규칙을 값 객체 안에 기술하여 코드 자체가 문서가 되로록 할 수 있다.